{
  "tasks": [
    {
      "id": "1",
      "title": "Create USAGE.html - Comprehensive Usage Guide",
      "description": "Create a single HTML file covering installation, all CLI commands, common workflows, troubleshooting, and next steps",
      "status": "done",
      "priority": "high",
      "dependencies": [],
      "phase": "Documentation",
      "details": "Include: npm/npx install, kickoff create/list/stacks/docs/config commands with examples, SaaS/AI/Python/Go workflows, troubleshooting (port conflicts, node version, template errors, git issues), env vars reference",
      "updatedAt": "2025-12-18T09:40:00.000Z",
      "subtasks": []
    },
    {
      "id": "2",
      "title": "Create comprehensive STACKS.html with ALL options",
      "description": "Create single HTML file with every stack option from types.ts - project types, databases, ORMs, auth, runtimes, AI frameworks, vector DBs, embeddings, local AI, web servers, and presets",
      "status": "done",
      "priority": "high",
      "dependencies": [],
      "phase": "Documentation",
      "details": "Include: 18 project types, 18 databases, 12 ORMs, 12 auth providers, 6 runtimes, 7 AI frameworks, 9 vector DBs, 9 embedding providers, 11 local AI providers, 4 web servers, 14 presets. Each with name, description, use cases, env vars, costs, compatibility",
      "subtasks": [],
      "updatedAt": "2025-12-18T09:40:00.000Z"
    },
    {
      "id": "3",
      "title": "Delete redundant documentation files",
      "description": "Remove QUICK_START.html, PRESETS.html, QUESTIONNAIRE.md as they are merged into the new files",
      "status": "done",
      "priority": "medium",
      "dependencies": [
        "1",
        "2"
      ],
      "phase": "Cleanup",
      "details": "Delete: docs/QUICK_START.html, docs/PRESETS.html, docs/QUESTIONNAIRE.md",
      "subtasks": [],
      "updatedAt": "2025-12-18T09:40:00.000Z"
    },
    {
      "id": "4",
      "title": "Update CLI to point to new documentation files",
      "description": "Update cli.ts: kickoff docs opens USAGE.html, kickoff stacks opens STACKS.html, remove kickoff presets command",
      "status": "done",
      "priority": "high",
      "dependencies": [
        "1",
        "2"
      ],
      "phase": "Implementation",
      "details": "Modify src/cli.ts to update file paths and remove presets command",
      "subtasks": [],
      "updatedAt": "2025-12-18T09:40:00.000Z"
    },
    {
      "id": "5",
      "title": "Add vitest.config.ts",
      "description": "Create vitest configuration file with TypeScript support, coverage config, and proper include/exclude patterns",
      "status": "done",
      "priority": "low",
      "dependencies": [],
      "phase": "Testing",
      "details": "Configure vitest for ESM, TypeScript, v8 coverage",
      "subtasks": [],
      "updatedAt": "2025-12-18T09:40:00.000Z"
    },
    {
      "id": "6",
      "title": "Final build and verification",
      "description": "Run build, tests, verify CLI commands, test HTML files open correctly",
      "status": "done",
      "priority": "high",
      "dependencies": [
        "3",
        "4",
        "5"
      ],
      "phase": "Verification",
      "details": "npm run build, npm test, test all kickoff commands, verify HTML opens",
      "subtasks": [],
      "updatedAt": "2025-12-18T09:40:00.000Z"
    }
  ],
  "metadata": {
    "version": "1.0.0",
    "lastModified": "2025-12-18T09:40:00.000Z",
    "taskCount": 6,
    "completedCount": 6,
    "tags": [
      "master"
    ]
  },
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Create Stack Knowledge Base Types",
        "description": "Define TypeScript interfaces for all stack options and create the base structure for the knowledge base",
        "details": "Create the core type definitions that will be used throughout the knowledge base system. This includes:\n\n1. Define the `StackOption` interface with required fields:\n```typescript\ninterface StackOption {\n  id: string;\n  name: string;\n  description: string;\n  pros: string[];\n  cons: string[];\n  tradeoffs: string[];\n  bestFor: string[];\n  monthlyCost: {\n    free: boolean;\n    hobbyist: string | null;\n    startup: string | null;\n    enterprise: string | null;\n  };\n  requiredEnvVars: string[];\n  compatibleWith: string[];\n  incompatibleWith: string[];\n  complexity: 'low' | 'medium' | 'high';\n}\n```\n\n2. Create specialized interfaces for each stack category:\n```typescript\ninterface Database extends StackOption {\n  scalability: 'low' | 'medium' | 'high';\n  queryLanguage: string;\n}\n\ninterface ORM extends StackOption {\n  supportedDatabases: string[];\n  typeSafety: boolean;\n}\n\n// Similar interfaces for Auth, Frontend, Backend, AI, VectorDB, Runtime\n```\n\n3. Create a type for the compatibility matrix:\n```typescript\ntype CompatibilityMatrix = Record<string, {\n  compatibleWith: string[];\n  incompatibleWith: string[];\n}>\n```\n\nImplement these in src/knowledge/types.ts and export them for use in other knowledge base files.",
        "testStrategy": "Create unit tests to verify type definitions are correctly structured. Use TypeScript's type checking to ensure all interfaces are properly defined. Test with sample data to ensure the types work as expected.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-18T10:01:45.486Z"
      },
      {
        "id": "2",
        "title": "Implement Stack Knowledge Base Data Files",
        "description": "Create comprehensive knowledge files for all stack options including databases, ORMs, auth providers, frameworks, AI tools, and vector DBs",
        "details": "Implement the knowledge base data files using the types defined in Task 1. Each file should export an array of options for its category:\n\n1. Create `src/knowledge/databases.ts` with 18 database options including:\n```typescript\nimport { Database } from './types';\n\nexport const databases: Database[] = [\n  {\n    id: 'postgres',\n    name: 'PostgreSQL',\n    description: 'Open-source relational database with strong SQL compliance',\n    pros: ['Mature and stable', 'Strong data integrity', 'Rich feature set'],\n    cons: ['Can be complex to optimize', 'Requires more resources than SQLite'],\n    tradeoffs: ['Power vs simplicity', 'Features vs resource usage'],\n    bestFor: ['Complex applications', 'Data-intensive workloads'],\n    monthlyCost: { free: true, hobbyist: '$0', startup: '$50-200', enterprise: '$200+' },\n    requiredEnvVars: ['DATABASE_URL'],\n    compatibleWith: ['prisma', 'drizzle', 'sequelize', 'typeorm'],\n    incompatibleWith: [],\n    complexity: 'medium',\n    scalability: 'high',\n    queryLanguage: 'SQL'\n  },\n  // 17 more database entries\n];\n```\n\n2. Similarly implement:\n- `src/knowledge/orms.ts` with 12 ORM options\n- `src/knowledge/auth.ts` with 12 auth options\n- `src/knowledge/frameworks.ts` with frontend and backend frameworks\n- `src/knowledge/ai.ts` with AI frameworks and vector DBs\n- `src/knowledge/runtimes.ts` with 6 runtime options\n\n3. Create `src/knowledge/compatibility.ts` with a compatibility matrix:\n```typescript\nimport { CompatibilityMatrix } from './types';\n\nexport const compatibility: CompatibilityMatrix = {\n  'postgres': {\n    compatibleWith: ['prisma', 'drizzle', 'sequelize', 'typeorm', 'node', 'bun'],\n    incompatibleWith: []\n  },\n  // More compatibility entries\n};\n```\n\n4. Create `src/knowledge/index.ts` to export all knowledge base components:\n```typescript\nexport * from './types';\nexport * from './databases';\nexport * from './orms';\n// Export all other knowledge files\n```",
        "testStrategy": "Create unit tests to verify all knowledge base entries conform to their respective interfaces. Test that each category has the correct number of options. Validate that compatibility relationships are bidirectional (if A is compatible with B, B should be compatible with A). Check for data consistency across all files.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "3",
        "title": "Create Recommendation Scoring Engine",
        "description": "Build a scoring system that evaluates stack options based on user requirements and generates explanations",
        "details": "Implement the recommendation scoring engine that will rank stack options based on user inputs:\n\n1. Create `src/recommender/types.ts` with scoring interfaces:\n```typescript\nimport { StackOption } from '../knowledge/types';\n\ninterface ScoreFactors {\n  complexity: number;\n  cost: number;\n  ecosystem: number;\n  features: number;\n}\n\ninterface ScoredOption<T extends StackOption> {\n  option: T;\n  score: number;\n  reasoning: string[];\n  warnings: string[];\n}\n\ninterface UserRequirements {\n  budget: 'free' | 'low' | 'medium' | 'high';\n  complexity: 'beginner' | 'intermediate' | 'advanced';\n  scale: 'small' | 'medium' | 'large';\n  timeline: 'fast' | 'normal' | 'flexible';\n  priorities: string[];\n  // Additional requirements based on questionnaire\n}\n```\n\n2. Implement `src/recommender/scorer.ts` with scoring algorithm:\n```typescript\nimport { ScoreFactors, ScoredOption, UserRequirements } from './types';\nimport { StackOption } from '../knowledge/types';\n\nexport function scoreOption<T extends StackOption>(\n  option: T,\n  requirements: UserRequirements,\n  weights: ScoreFactors\n): ScoredOption<T> {\n  // Calculate base score\n  let score = 0;\n  const reasoning: string[] = [];\n  const warnings: string[] = [];\n  \n  // Score based on complexity\n  if (requirements.complexity === 'beginner' && option.complexity === 'high') {\n    score -= weights.complexity;\n    warnings.push(`${option.name} has high complexity which may not be suitable for beginners`);\n  }\n  \n  // Score based on cost\n  // Score based on compatibility\n  // Score based on features\n  \n  return { option, score, reasoning, warnings };\n}\n```\n\n3. Create `src/recommender/explainer.ts` for generating human-readable explanations:\n```typescript\nimport { ScoredOption } from './types';\nimport { StackOption } from '../knowledge/types';\n\nexport function generateExplanation<T extends StackOption>(scored: ScoredOption<T>): string {\n  // Generate detailed explanation of why this option was recommended\n  const { option, reasoning, warnings } = scored;\n  \n  let explanation = `${option.name} was selected because:\\n`;\n  reasoning.forEach(reason => {\n    explanation += `- ${reason}\\n`;\n  });\n  \n  if (warnings.length > 0) {\n    explanation += '\\nConsiderations:\\n';\n    warnings.forEach(warning => {\n      explanation += `- ${warning}\\n`;\n    });\n  }\n  \n  return explanation;\n}\n```\n\n4. Create `src/recommender/index.ts` to export the recommendation engine:\n```typescript\nexport * from './types';\nexport * from './scorer';\nexport * from './explainer';\n\nimport { UserRequirements } from './types';\nimport { StackOption } from '../knowledge/types';\nimport { scoreOption } from './scorer';\n\nexport function recommendOptions<T extends StackOption>(\n  options: T[],\n  requirements: UserRequirements\n) {\n  // Score all options\n  // Sort by score\n  // Return top recommendations with explanations\n}\n```",
        "testStrategy": "Create unit tests for the scoring algorithm with various user requirement scenarios. Test that the scoring correctly prioritizes options based on different user needs. Verify that explanations are generated correctly and include all relevant reasoning. Test edge cases like when no good options exist for specific requirements.",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "4",
        "title": "Build Questionnaire Flow System",
        "description": "Create a question flow engine with support for different question types, conditional logic, and branching",
        "details": "Implement the questionnaire flow system that will guide users through stack selection:\n\n1. Create `src/questionnaire/types.ts` with question interfaces:\n```typescript\ntype QuestionType = 'single' | 'multi' | 'confirm' | 'input';\n\ninterface BaseQuestion {\n  id: string;\n  type: QuestionType;\n  message: string;\n  description?: string;\n  icon?: string;\n  showWhen?: (answers: Record<string, any>) => boolean;\n}\n\ninterface SingleChoiceQuestion extends BaseQuestion {\n  type: 'single';\n  choices: Array<{\n    value: string;\n    name: string;\n    description?: string;\n  }>;\n}\n\ninterface MultiChoiceQuestion extends BaseQuestion {\n  type: 'multi';\n  choices: Array<{\n    value: string;\n    name: string;\n    description?: string;\n  }>;\n}\n\ninterface ConfirmQuestion extends BaseQuestion {\n  type: 'confirm';\n  default?: boolean;\n}\n\ninterface InputQuestion extends BaseQuestion {\n  type: 'input';\n  default?: string;\n  validate?: (input: string) => boolean | string;\n}\n\ntype Question = SingleChoiceQuestion | MultiChoiceQuestion | ConfirmQuestion | InputQuestion;\n```\n\n2. Implement `src/questionnaire/flow.ts` with the flow engine:\n```typescript\nimport { Question } from './types';\n\nexport class QuestionFlow {\n  private questions: Question[];\n  private answers: Record<string, any> = {};\n  \n  constructor(questions: Question[]) {\n    this.questions = questions;\n  }\n  \n  getNextQuestion(): Question | null {\n    // Find the next question that should be shown based on previous answers\n    return this.questions.find(q => {\n      if (q.showWhen) {\n        return q.showWhen(this.answers);\n      }\n      return true;\n    }) || null;\n  }\n  \n  setAnswer(questionId: string, answer: any): void {\n    this.answers[questionId] = answer;\n  }\n  \n  getAnswers(): Record<string, any> {\n    return { ...this.answers };\n  }\n}\n```\n\n3. Create `src/questionnaire/questions.ts` with all question definitions:\n```typescript\nimport { Question } from './types';\n\nexport const questions: Question[] = [\n  {\n    id: 'projectType',\n    type: 'single',\n    message: 'What type of project are you building?',\n    icon: 'üèóÔ∏è',\n    description: 'This will help us recommend the most suitable stack',\n    choices: [\n      { value: 'webapp', name: 'Web Application', description: 'Full-stack web app with frontend and backend' },\n      { value: 'api', name: 'API Service', description: 'Backend API service only' },\n      { value: 'ai', name: 'AI Application', description: 'Application with AI/ML components' },\n      // More choices\n    ]\n  },\n  {\n    id: 'database',\n    type: 'single',\n    message: 'Which database would you like to use?',\n    icon: 'üóÑÔ∏è',\n    description: 'Select the primary database for your application',\n    showWhen: (answers) => answers.projectType !== 'static',\n    choices: [] // Will be populated from knowledge base\n  },\n  // More questions with conditional logic\n];\n```",
        "testStrategy": "Create unit tests for the question flow logic, testing conditional questions and branching paths. Verify that questions are correctly shown or hidden based on previous answers. Test the flow with different answer combinations to ensure all paths work correctly. Validate that the final answers object contains all expected data.",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "5",
        "title": "Create Interactive CLI Renderer",
        "description": "Build a rich CLI UI that displays questions, pros/cons boxes, comparison tables, and final stack summary",
        "details": "Implement the CLI renderer for the interactive questionnaire:\n\n1. Install required dependencies:\n```bash\nnpm install @inquirer/prompts boxen chalk\n```\n\n2. Create `src/questionnaire/renderer.ts` with rendering functions:\n```typescript\nimport { select, checkbox, confirm, input } from '@inquirer/prompts';\nimport boxen from 'boxen';\nimport chalk from 'chalk';\nimport { Question, SingleChoiceQuestion, MultiChoiceQuestion } from './types';\nimport { StackOption } from '../knowledge/types';\n\nexport async function renderQuestion(question: Question): Promise<any> {\n  console.log(chalk.bold(`${question.icon || '‚ùì'} ${question.message}`))\n  if (question.description) {\n    console.log(chalk.dim(question.description));\n    console.log();\n  }\n  \n  switch (question.type) {\n    case 'single':\n      return renderSingleChoice(question);\n    case 'multi':\n      return renderMultiChoice(question);\n    case 'confirm':\n      return renderConfirm(question);\n    case 'input':\n      return renderInput(question);\n  }\n}\n\nasync function renderSingleChoice(question: SingleChoiceQuestion): Promise<string> {\n  return select({\n    message: question.message,\n    choices: question.choices.map(choice => ({\n      value: choice.value,\n      name: choice.name,\n      description: choice.description\n    }))\n  });\n}\n\n// Implement renderMultiChoice, renderConfirm, renderInput\n\nexport function renderOptionDetails<T extends StackOption>(option: T): void {\n  console.log(boxen(\n    `${chalk.bold(option.name)}\\n\\n${option.description}`,\n    { padding: 1, borderColor: 'blue', title: 'Option Details' }\n  ));\n  \n  console.log(boxen(\n    `${chalk.green.bold('PROS')}\\n${option.pros.map(pro => `‚Ä¢ ${pro}`).join('\\n')}`,\n    { padding: 1, borderColor: 'green', width: 40, float: 'left' }\n  ));\n  \n  console.log(boxen(\n    `${chalk.red.bold('CONS')}\\n${option.cons.map(con => `‚Ä¢ ${con}`).join('\\n')}`,\n    { padding: 1, borderColor: 'red', width: 40, float: 'right' }\n  ));\n  \n  console.log(boxen(\n    `${chalk.yellow.bold('TRADEOFFS')}\\n${option.tradeoffs.map(tradeoff => `‚Ä¢ ${tradeoff}`).join('\\n')}`,\n    { padding: 1, borderColor: 'yellow', width: 80 }\n  ));\n}\n\nexport function renderFinalSummary(selections: Record<string, StackOption>, reasoning: Record<string, string>): void {\n  console.log(boxen(\n    chalk.bold('üéâ Your Stack Selection'),\n    { padding: 1, borderColor: 'green', title: 'Summary' }\n  ));\n  \n  // Render each selection with its reasoning\n  Object.entries(selections).forEach(([category, option]) => {\n    console.log(chalk.bold(`\\n${category}: ${option.name}`));\n    console.log(chalk.dim(reasoning[category]));\n  });\n}\n```\n\n3. Create `src/questionnaire/index.ts` to integrate flow and renderer:\n```typescript\nimport { QuestionFlow } from './flow';\nimport { questions } from './questions';\nimport { renderQuestion, renderOptionDetails, renderFinalSummary } from './renderer';\nimport { recommendOptions } from '../recommender';\nimport * as knowledge from '../knowledge';\n\nexport async function runQuestionnaire() {\n  const flow = new QuestionFlow(questions);\n  let question = flow.getNextQuestion();\n  \n  while (question) {\n    // For stack selection questions, show details before asking\n    if (question.id.startsWith('select')) {\n      const category = question.id.replace('select', '').toLowerCase();\n      const options = knowledge[category];\n      \n      // If this is a single choice question, show details for each option\n      if (question.type === 'single' && options) {\n        for (const choice of question.choices) {\n          const option = options.find(o => o.id === choice.value);\n          if (option) renderOptionDetails(option);\n        }\n      }\n    }\n    \n    const answer = await renderQuestion(question);\n    flow.setAnswer(question.id, answer);\n    question = flow.getNextQuestion();\n  }\n  \n  const answers = flow.getAnswers();\n  return answers;\n}\n```",
        "testStrategy": "Test the renderer with mock questions and options to verify correct display. Create integration tests that run through the questionnaire flow with automated inputs. Verify that the UI elements (boxes, colors, formatting) render correctly. Test with different terminal sizes to ensure responsive display. Mock console.log and verify output formatting.",
        "priority": "medium",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "6",
        "title": "Refactor Templates into Composable Modules",
        "description": "Split existing templates into composable fragments for different stack components",
        "details": "Refactor the template system to support composable fragments:\n\n1. Create directory structure for template fragments:\n```\nsrc/templates/fragments/\n  base/\n    README.md.ejs\n    CLAUDE.md.ejs\n    .gitignore.ejs\n    .env.example.ejs\n  runtime/\n    node/\n    bun/\n    python/\n    go/\n    rust/\n  frontend/\n    nextjs/\n    tanstack/\n    vite-react/\n  backend/\n    hono/\n    express/\n    fastapi/\n    gin/\n  database/\n    supabase/\n    neon/\n    turso/\n    postgres/\n  orm/\n    drizzle/\n    prisma/\n    sqlalchemy/\n  auth/\n    clerk/\n    better-auth/\n    supabase-auth/\n  ai/\n    vercel-ai/\n    langchain/\n    ollama/\n  deployment/\n    docker/\n    github-actions/\n```\n\n2. Create `src/generator/types.ts` with fragment interfaces:\n```typescript\ninterface TemplateFragment {\n  id: string;\n  category: 'base' | 'runtime' | 'frontend' | 'backend' | 'database' | 'orm' | 'auth' | 'ai' | 'deployment';\n  path: string;\n  dependencies?: string[];\n  files: Array<{\n    source: string;\n    destination: string;\n    condition?: (context: TemplateContext) => boolean;\n  }>;\n  packageJson?: {\n    dependencies?: Record<string, string>;\n    devDependencies?: Record<string, string>;\n    scripts?: Record<string, string>;\n  };\n  envVars?: Array<{\n    key: string;\n    defaultValue?: string;\n    description: string;\n    required: boolean;\n  }>;\n}\n\ninterface TemplateContext {\n  projectName: string;\n  selections: Record<string, string>;\n  options: Record<string, any>;\n}\n```\n\n3. Refactor existing templates into fragments following this structure. For example, a Next.js fragment might look like:\n```typescript\nimport { TemplateFragment } from '../types';\n\nexport const nextjsFragment: TemplateFragment = {\n  id: 'nextjs',\n  category: 'frontend',\n  path: 'frontend/nextjs',\n  dependencies: ['node'],\n  files: [\n    { source: 'next.config.js.ejs', destination: 'next.config.js' },\n    { source: 'tsconfig.json.ejs', destination: 'tsconfig.json' },\n    { source: 'src/app/layout.tsx.ejs', destination: 'src/app/layout.tsx' },\n    { source: 'src/app/page.tsx.ejs', destination: 'src/app/page.tsx' },\n    // More files\n  ],\n  packageJson: {\n    dependencies: {\n      'next': '^13.4.0',\n      'react': '^18.2.0',\n      'react-dom': '^18.2.0'\n    },\n    devDependencies: {\n      '@types/react': '^18.2.0',\n      '@types/react-dom': '^18.2.0'\n    },\n    scripts: {\n      'dev': 'next dev',\n      'build': 'next build',\n      'start': 'next start'\n    }\n  },\n  envVars: [\n    { key: 'NEXT_PUBLIC_API_URL', description: 'URL for the backend API', required: false }\n  ]\n};\n```\n\n4. Create index files to export all fragments for each category.",
        "testStrategy": "Create unit tests to verify all template fragments are correctly structured. Test that each fragment contains the required files and dependencies. Verify that the fragments can be loaded and parsed correctly. Create integration tests that combine different fragments to ensure they work together without conflicts.",
        "priority": "medium",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "7",
        "title": "Implement Template Stitching Engine",
        "description": "Create a generator that collects required fragments, resolves dependencies, and merges files intelligently",
        "details": "Implement the template stitching engine that will combine fragments into a complete project:\n\n1. Create `src/generator/collector.ts` to collect required fragments:\n```typescript\nimport { TemplateFragment, TemplateContext } from './types';\nimport * as fragments from '../templates/fragments';\n\nexport function collectFragments(context: TemplateContext): TemplateFragment[] {\n  const selectedFragments: TemplateFragment[] = [];\n  \n  // Always include base fragments\n  selectedFragments.push(...fragments.base);\n  \n  // Add fragments based on selections\n  Object.entries(context.selections).forEach(([category, selection]) => {\n    const categoryFragments = fragments[category];\n    if (categoryFragments) {\n      const fragment = categoryFragments.find(f => f.id === selection);\n      if (fragment) selectedFragments.push(fragment);\n    }\n  });\n  \n  return selectedFragments;\n}\n```\n\n2. Create `src/generator/resolver.ts` to resolve dependencies:\n```typescript\nimport { TemplateFragment } from './types';\n\nexport function resolveDependencies(fragments: TemplateFragment[]): TemplateFragment[] {\n  const resolvedFragments = [...fragments];\n  const fragmentIds = new Set(fragments.map(f => f.id));\n  \n  // Check for missing dependencies\n  fragments.forEach(fragment => {\n    if (fragment.dependencies) {\n      fragment.dependencies.forEach(depId => {\n        if (!fragmentIds.has(depId)) {\n          // Find the missing dependency fragment\n          const missingFragment = allFragments.find(f => f.id === depId);\n          if (missingFragment) {\n            resolvedFragments.push(missingFragment);\n            fragmentIds.add(depId);\n          }\n        }\n      });\n    }\n  });\n  \n  // Sort fragments by dependency order\n  return topologicalSort(resolvedFragments);\n}\n\nfunction topologicalSort(fragments: TemplateFragment[]): TemplateFragment[] {\n  // Implement topological sort to order fragments by dependencies\n  // This ensures dependent fragments come after their dependencies\n}\n```\n\n3. Create `src/generator/merger.ts` to merge files and resolve conflicts:\n```typescript\nimport { TemplateFragment, TemplateContext } from './types';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as ejs from 'ejs';\n\nexport async function mergeFragments(\n  fragments: TemplateFragment[],\n  context: TemplateContext,\n  outputDir: string\n): Promise<void> {\n  // Prepare merged package.json\n  const packageJson = {\n    name: context.projectName,\n    version: '0.1.0',\n    private: true,\n    dependencies: {},\n    devDependencies: {},\n    scripts: {}\n  };\n  \n  // Prepare merged .env.example\n  const envVars: Record<string, { value: string, description: string, required: boolean }> = {};\n  \n  // Process each fragment\n  for (const fragment of fragments) {\n    // Merge package.json entries\n    if (fragment.packageJson) {\n      if (fragment.packageJson.dependencies) {\n        Object.assign(packageJson.dependencies, fragment.packageJson.dependencies);\n      }\n      if (fragment.packageJson.devDependencies) {\n        Object.assign(packageJson.devDependencies, fragment.packageJson.devDependencies);\n      }\n      if (fragment.packageJson.scripts) {\n        Object.assign(packageJson.scripts, fragment.packageJson.scripts);\n      }\n    }\n    \n    // Collect env vars\n    if (fragment.envVars) {\n      fragment.envVars.forEach(env => {\n        envVars[env.key] = {\n          value: env.defaultValue || '',\n          description: env.description,\n          required: env.required\n        };\n      });\n    }\n    \n    // Process template files\n    for (const file of fragment.files) {\n      if (file.condition && !file.condition(context)) continue;\n      \n      const sourcePath = path.join(__dirname, '..', 'templates', 'fragments', fragment.path, file.source);\n      const destPath = path.join(outputDir, file.destination);\n      \n      // Create directory if it doesn't exist\n      const destDir = path.dirname(destPath);\n      if (!fs.existsSync(destDir)) {\n        fs.mkdirSync(destDir, { recursive: true });\n      }\n      \n      // Render template with EJS\n      const template = fs.readFileSync(sourcePath, 'utf-8');\n      const rendered = ejs.render(template, context);\n      \n      // Write file\n      fs.writeFileSync(destPath, rendered);\n    }\n  }\n  \n  // Write merged package.json\n  fs.writeFileSync(\n    path.join(outputDir, 'package.json'),\n    JSON.stringify(packageJson, null, 2)\n  );\n  \n  // Write merged .env.example\n  let envContent = '# Environment Variables\\n\\n';\n  Object.entries(envVars).forEach(([key, { value, description, required }]) => {\n    envContent += `# ${description}\\n`;\n    envContent += required ? `${key}=${value}\\n\\n` : `# ${key}=${value}\\n\\n`;\n  });\n  fs.writeFileSync(path.join(outputDir, '.env.example'), envContent);\n}\n```\n\n4. Create `src/generator/index.ts` to export the generator:\n```typescript\nexport * from './types';\nimport { collectFragments } from './collector';\nimport { resolveDependencies } from './resolver';\nimport { mergeFragments } from './merger';\nimport { TemplateContext } from './types';\n\nexport async function generateProject(\n  context: TemplateContext,\n  outputDir: string\n): Promise<void> {\n  // Collect fragments based on user selections\n  const fragments = collectFragments(context);\n  \n  // Resolve dependencies and order fragments\n  const orderedFragments = resolveDependencies(fragments);\n  \n  // Merge and output files\n  await mergeFragments(orderedFragments, context, outputDir);\n}\n```",
        "testStrategy": "Create unit tests for fragment collection, dependency resolution, and file merging. Test with various combinations of fragments to ensure correct dependency resolution. Verify that package.json merging correctly handles conflicting versions. Test env var collection and merging. Create integration tests that generate complete projects with different stack combinations and verify the output structure.",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "8",
        "title": "Integrate Questionnaire with Generator",
        "description": "Connect the questionnaire system with the template generator and update the CLI interface",
        "details": "Integrate the questionnaire flow with the template generator and update the CLI interface:\n\n1. Update `src/cli.ts` to support the interactive mode:\n```typescript\nimport { Command } from 'commander';\nimport { runQuestionnaire } from './questionnaire';\nimport { generateProject } from './generator';\nimport { mapAnswersToContext } from './lib/mapper';\n\nconst program = new Command();\n\nprogram\n  .name('create-stack')\n  .description('Create a new project with an intelligent stack selection')\n  .version('1.0.0');\n\nprogram\n  .command('create')\n  .description('Create a new project')\n  .argument('<project-name>', 'Name of the project')\n  .option('--interactive', 'Run in interactive mode with smart questionnaire', true)\n  .option('--preset <preset>', 'Use a predefined preset')\n  .option('--output-dir <dir>', 'Output directory', './')\n  .action(async (projectName, options) => {\n    let context;\n    \n    if (options.preset) {\n      // Use preset configuration\n      context = loadPreset(options.preset, projectName);\n    } else if (options.interactive) {\n      // Run interactive questionnaire\n      const answers = await runQuestionnaire();\n      context = mapAnswersToContext(answers, projectName);\n    } else {\n      console.error('Either --interactive or --preset must be specified');\n      process.exit(1);\n    }\n    \n    // Generate project\n    const outputDir = path.join(options.outputDir, projectName);\n    await generateProject(context, outputDir);\n    \n    console.log(`\\nüéâ Project ${projectName} created successfully in ${outputDir}`);\n  });\n\nprogram.parse();\n```\n\n2. Create `src/lib/mapper.ts` to map questionnaire answers to template context:\n```typescript\nimport { TemplateContext } from '../generator/types';\nimport * as knowledge from '../knowledge';\n\nexport function mapAnswersToContext(answers: Record<string, any>, projectName: string): TemplateContext {\n  const selections: Record<string, string> = {};\n  const options: Record<string, any> = {};\n  \n  // Map category selections\n  if (answers.database) selections.database = answers.database;\n  if (answers.orm) selections.orm = answers.orm;\n  if (answers.auth) selections.auth = answers.auth;\n  if (answers.frontend) selections.frontend = answers.frontend;\n  if (answers.backend) selections.backend = answers.backend;\n  if (answers.ai) selections.ai = answers.ai;\n  if (answers.vectorDb) selections.vectorDb = answers.vectorDb;\n  if (answers.runtime) selections.runtime = answers.runtime;\n  \n  // Map additional options\n  options.includeTests = answers.includeTests || false;\n  options.includeDocker = answers.includeDocker || false;\n  options.includeCi = answers.includeCi || false;\n  \n  return {\n    projectName,\n    selections,\n    options\n  };\n}\n```\n\n3. Update `src/lib/prompter.ts` to use the new questionnaire system:\n```typescript\nimport { runQuestionnaire } from '../questionnaire';\nimport { mapAnswersToContext } from './mapper';\n\nexport async function promptForProjectDetails(projectName: string) {\n  const answers = await runQuestionnaire();\n  return mapAnswersToContext(answers, projectName);\n}\n```",
        "testStrategy": "Create integration tests that run through the entire flow from questionnaire to project generation. Test with various answer combinations to ensure correct template selection. Verify that the CLI correctly handles both interactive mode and preset mode. Test error handling for invalid inputs or missing dependencies. Create end-to-end tests that generate complete projects and verify their structure.",
        "priority": "high",
        "dependencies": [
          "5",
          "7"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "9",
        "title": "Add Tests and Verification",
        "description": "Create comprehensive tests for all components and verify that existing presets still work",
        "details": "Implement comprehensive tests for all system components:\n\n1. Create knowledge base validation tests in `src/knowledge/*.test.ts`:\n```typescript\nimport { databases } from './databases';\nimport { orms } from './orms';\nimport { auth } from './auth';\nimport { compatibility } from './compatibility';\n\ndescribe('Knowledge Base Validation', () => {\n  test('All databases have required fields', () => {\n    databases.forEach(db => {\n      expect(db.id).toBeDefined();\n      expect(db.name).toBeDefined();\n      expect(db.description).toBeDefined();\n      expect(Array.isArray(db.pros)).toBeTruthy();\n      expect(Array.isArray(db.cons)).toBeTruthy();\n      expect(Array.isArray(db.tradeoffs)).toBeTruthy();\n      expect(Array.isArray(db.bestFor)).toBeTruthy();\n      expect(db.monthlyCost).toBeDefined();\n      expect(Array.isArray(db.requiredEnvVars)).toBeTruthy();\n      expect(Array.isArray(db.compatibleWith)).toBeTruthy();\n      expect(Array.isArray(db.incompatibleWith)).toBeTruthy();\n      expect(['low', 'medium', 'high']).toContain(db.complexity);\n    });\n  });\n  \n  test('Compatibility relationships are bidirectional', () => {\n    // For each compatibility relationship, check that it works both ways\n    Object.entries(compatibility).forEach(([id, { compatibleWith }]) => {\n      compatibleWith.forEach(otherId => {\n        if (compatibility[otherId]) {\n          expect(compatibility[otherId].compatibleWith).toContain(id);\n        }\n      });\n    });\n  });\n  \n  // More knowledge base validation tests\n});\n```\n\n2. Create questionnaire flow tests in `src/questionnaire/*.test.ts`:\n```typescript\nimport { QuestionFlow } from './flow';\nimport { questions } from './questions';\n\ndescribe('Questionnaire Flow', () => {\n  test('Initial question is shown', () => {\n    const flow = new QuestionFlow(questions);\n    const firstQuestion = flow.getNextQuestion();\n    expect(firstQuestion).not.toBeNull();\n    expect(firstQuestion?.id).toBe('projectType');\n  });\n  \n  test('Conditional questions are shown based on answers', () => {\n    const flow = new QuestionFlow(questions);\n    \n    // Answer first question\n    flow.setAnswer('projectType', 'webapp');\n    \n    // Next question should be database for webapp\n    const nextQuestion = flow.getNextQuestion();\n    expect(nextQuestion?.id).toBe('database');\n    \n    // If we had chosen 'static', database question should be skipped\n    const staticFlow = new QuestionFlow(questions);\n    staticFlow.setAnswer('projectType', 'static');\n    const staticNextQuestion = staticFlow.getNextQuestion();\n    expect(staticNextQuestion?.id).not.toBe('database');\n  });\n  \n  // More flow tests\n});\n```\n\n3. Create generator tests in `src/generator/*.test.ts`:\n```typescript\nimport { collectFragments } from './collector';\nimport { resolveDependencies } from './resolver';\nimport { mergeFragments } from './merger';\nimport { generateProject } from './index';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\ndescribe('Template Generator', () => {\n  const testContext = {\n    projectName: 'test-project',\n    selections: {\n      runtime: 'node',\n      frontend: 'nextjs',\n      database: 'postgres',\n      orm: 'prisma'\n    },\n    options: {\n      includeTests: true\n    }\n  };\n  \n  test('Collects correct fragments based on selections', () => {\n    const fragments = collectFragments(testContext);\n    \n    // Should include base fragments\n    expect(fragments.some(f => f.category === 'base')).toBeTruthy();\n    \n    // Should include selected fragments\n    expect(fragments.some(f => f.id === 'node')).toBeTruthy();\n    expect(fragments.some(f => f.id === 'nextjs')).toBeTruthy();\n    expect(fragments.some(f => f.id === 'postgres')).toBeTruthy();\n    expect(fragments.some(f => f.id === 'prisma')).toBeTruthy();\n  });\n  \n  test('Resolves dependencies correctly', () => {\n    const fragments = collectFragments(testContext);\n    const resolved = resolveDependencies(fragments);\n    \n    // Check dependency order\n    const nodeIndex = resolved.findIndex(f => f.id === 'node');\n    const nextjsIndex = resolved.findIndex(f => f.id === 'nextjs');\n    expect(nodeIndex).toBeLessThan(nextjsIndex);\n  });\n  \n  // More generator tests\n});\n```\n\n4. Create E2E tests that verify complete project generation:\n```typescript\nimport { execSync } from 'child_process';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\ndescribe('E2E Project Generation', () => {\n  const testDir = path.join(__dirname, '..', '..', 'test-output');\n  \n  beforeAll(() => {\n    // Create test directory\n    if (!fs.existsSync(testDir)) {\n      fs.mkdirSync(testDir, { recursive: true });\n    }\n  });\n  \n  afterAll(() => {\n    // Clean up test directory\n    fs.rmSync(testDir, { recursive: true, force: true });\n  });\n  \n  test('Generates a Next.js project with Postgres and Prisma', () => {\n    const projectName = 'nextjs-postgres-test';\n    const outputDir = path.join(testDir, projectName);\n    \n    // Run CLI with preset\n    execSync(`node ./dist/cli.js create ${projectName} --preset nextjs-postgres --output-dir ${testDir}`);\n    \n    // Verify files exist\n    expect(fs.existsSync(path.join(outputDir, 'package.json'))).toBeTruthy();\n    expect(fs.existsSync(path.join(outputDir, 'next.config.js'))).toBeTruthy();\n    expect(fs.existsSync(path.join(outputDir, 'prisma/schema.prisma'))).toBeTruthy();\n    \n    // Verify package.json has correct dependencies\n    const packageJson = JSON.parse(fs.readFileSync(path.join(outputDir, 'package.json'), 'utf-8'));\n    expect(packageJson.dependencies.next).toBeDefined();\n    expect(packageJson.dependencies['@prisma/client']).toBeDefined();\n    expect(packageJson.devDependencies.prisma).toBeDefined();\n  });\n  \n  // More E2E tests for different stack combinations\n});\n```\n\n5. Verify that all existing presets still work with the new system.",
        "testStrategy": "Run all tests using Jest or another testing framework. Verify that knowledge base validation tests pass for all stack options. Test the questionnaire flow with different answer combinations. Verify that the generator correctly resolves dependencies and merges files. Run E2E tests for different stack combinations to ensure complete projects are generated correctly. Test backwards compatibility with existing presets.",
        "priority": "medium",
        "dependencies": [
          "2",
          "3",
          "4",
          "5",
          "7",
          "8"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "10",
        "title": "Create Documentation and Usage Examples",
        "description": "Create comprehensive documentation for the system and usage examples",
        "details": "Create documentation and usage examples for the system:\n\n1. Create a README.md file with:\n- Project overview and goals\n- Installation instructions\n- Usage examples for both interactive mode and preset mode\n- Available stack options\n- How to contribute\n\n2. Create documentation for extending the system:\n- How to add new stack options to the knowledge base\n- How to create new template fragments\n- How to define new presets\n\n3. Create usage examples for common stack combinations:\n```bash\n# Create a Next.js app with PostgreSQL and Prisma\nnpx create-stack create my-nextjs-app\n\n# Use a preset\nnpx create-stack create my-api --preset api-express-mongo\n\n# Non-interactive mode with specific options\nnpx create-stack create my-app --no-interactive --frontend nextjs --backend express --database postgres --orm prisma\n```\n\n4. Create a CONTRIBUTING.md file with guidelines for contributing to the project:\n- Code style and formatting\n- Testing requirements\n- Pull request process\n- How to add new stack options\n\n5. Update package.json with appropriate metadata:\n```json\n{\n  \"name\": \"create-stack\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Smart interactive questionnaire system for stack selection\",\n  \"keywords\": [\"stack\", \"generator\", \"template\", \"cli\", \"questionnaire\"],\n  \"author\": \"Your Name\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/yourusername/create-stack.git\"\n  },\n  \"bin\": {\n    \"create-stack\": \"./dist/cli.js\"\n  },\n  \"files\": [\n    \"dist\",\n    \"templates\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"test\": \"jest\",\n    \"lint\": \"eslint src --ext .ts\"\n  }\n}\n```",
        "testStrategy": "Verify that documentation is accurate and up-to-date. Test the usage examples to ensure they work as described. Review documentation for clarity and completeness. Ensure that the package.json metadata is correct and the bin entry points to the right file.",
        "priority": "low",
        "dependencies": [
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9"
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-18T10:01:45.487Z",
      "taskCount": 10,
      "completedCount": 1,
      "tags": [
        "master"
      ]
    }
  }
}